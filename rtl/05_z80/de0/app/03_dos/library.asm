; ----------------------------------------------------------------------
; Печать символа
; Вход: B(y=0..23), C(x=0..31) A(символ)
; ----------------------------------------------------------------------

PRINT_CHAR:

        PUSH    BC
        PUSH    DE
        PUSH    HL
        CALL    GET_SYMBOL_ADDRESS      ; HL=Адрес символа в памяти
        EX      DE, HL                  ; DE теперь тут
        CALL    GET_TEXT_CURSOR_ADDRESS ; HL=Адрес видеопамяти
        LD      B, 8            ; Повторить 8 раз
PC1:    LD      A, (DE)         ; Прочитать 8 бит
        LD      (HL), A         ; Записать 8 бит
        INC     H               ; Y = Y + 1 согласно модели памяти
        INC     DE              ; К следующему байту
        DJNZ    PC1             ; Рисовать 8 строк
        POP     HL
        POP     DE
        POP     BC
        RET

; ----------------------------------------------------------------------
; Вход:  B(Y=0..23), C(X=0..31)
; Выход: HL(адрес)
; ----------------------------------------------------------------------

GET_TEXT_CURSOR_ADDRESS:

        LD      A, C
        AND     0x1F
        LD      L, A    ; L = X & 31
        LD      A, B
        AND     0x07    ; Нужно ограничить 3 битами
        RRCA            ; Легче дойти с [0..2] до позиции [5..7]
        RRCA            ; Если вращать направо
        RRCA            ; ... три раза
        OR      L       ; Объединив с 0..4 уже готовыми ранее
        LD      L, A    ; Загрузить новый результат в L
        LD      A, B    ; Т.к. Y[3..5] уже на месте
        AND     0x18    ; Его двигать даже не надо
        OR      0x40    ; Ставим видеоадрес $4000
        LD      H, A    ; И загружаем результат
        RET

; ----------------------------------------------------------------------
; Вход:  A (символ)
; Выход: HL
; ----------------------------------------------------------------------

GET_SYMBOL_ADDRESS:

        SUB     0x20        ; A = Sym - 0x20
        LD      H, 0        ; HL = A
        LD      L, A
        ADD     HL, HL
        ADD     HL, HL
        ADD     HL, HL      ; HL = A << 3
        LD      A, H
        ADD     0x3D
        LD      H, A        ; HL += 0x3D00
        RET

; ----------------------------------------------------------------------
; Вход: A - атрибут очистки
; ----------------------------------------------------------------------

CLEAR_SCREEN:

        LD      BC, 0x02FF
        LD      HL, 0x5800  ; Отсюда копировать
        LD      DE, 0x5801  ; Сюда
        LD      (HL), A     ; Байт инициализации
        LDIR                ; Копировать из (HL) -> (DE), HL++, DE++
        XOR     A
        LD      HL, 0x4000
        LD      DE, 0x4001
        LD      BC, 0x17FF
        LDIR                ; Очистить графическую область
        RET
